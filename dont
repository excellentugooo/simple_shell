int devNull = open("/dev/null", O_WRONLY);
        if (devNull != -1)
        {
            dup2(devNull, STDERR_FILENO);
            close(devNull);
        }


#include "main.h"
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <stdlib.h>

void exec_ve(char *path, char *av[], char *env[])
{
    pid_t value;
    value = fork();

    if (value == -1)
        exit(EXIT_FAILURE);
    else if (value == 0)
    {
        execve(path, av, env);

        perror("Error");
        free(av);
        exit(EXIT_FAILURE);
    }
    else
    {
        wait(NULL);
    }
}

int execute_cmd(char *av[], char *env[], char *cmd)
{
    char *path = NULL;

    av = tokenize(cmd, " \n");
    path = find_path(av[0]);
    if (path == NULL)
    {
        if (av == NULL || av[0] == NULL)
        {
            free(cmd);
            exit(0);
        }
        else if (str_cmp(av[0], "exit") == 0)
            ex_it(av);
        else if (str_cmp(av[0], "env") == 0)
            envip(env);
        else if (str_cmp(av[0], "setenv") == 0)
            set_env(av);
        else if (strcmp(av[0], "unsetenv") == 0)
            unset_env(av);
        else if (strcmp(av[0], "cd") == 0)
            cd(av);
        else
            writes(":command not found\n", 1);
    }
    else
    {
        exec_ve(path, av, env);
    }

    return 0;
}

int main(__attribute__((unused)) int ac, char *av[], char *env[])
{
    char *input = NULL;
    char *cmd = NULL;
    ssize_t rvalue = 0;
    size_t n = 0;
    int last_status = 0;
    int should_execute = 1;

    while (1)
    {
        writes("simpleshell$ ", 1);

        rvalue = get_line(&input, &n, stdin);
        if (rvalue == -1)
            return -1;
        rmline(input);
        rmspace(input);
        rmit(input);
        cmd = strtok(input, ";");
        while (cmd != NULL)
        {
            rmspace(cmd);

            if (should_execute)
            {
                if (execute_cmd(av, env, cmd) != 0)
                {
                    last_status = 1;
                    should_execute = 0;
                }
                else
                {
                    last_status = 0;
                }
            }

            if (strcmp(cmd, "&&") == 0)
                should_execute = (last_status == 0);
            else if (strcmp(cmd, "||") == 0)
                should_execute = (last_status != 0);
            else
                should_execute = 1;

            cmd = strtok(NULL, ";");
        }
    }
    free(input);
    return 0;
}
#include "main.h"
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <stdlib.h>

#define MAX_ALIASES 100
#define MAX_ALIAS_LENGTH 100

typedef struct {
    char name[MAX_ALIAS_LENGTH];
    char value[MAX_ALIAS_LENGTH];
} Alias;

Alias aliases[MAX_ALIASES];
int numAliases = 0;

void print_alias(Alias *alias) {
    printf("%s='%s'\n", alias->name, alias->value);
}

void print_all_aliases() {
    for (int i = 0; i < numAliases; i++) {
        print_alias(&aliases[i]);
    }
}

Alias* find_alias(const char* name) {
    for (int i = 0; i < numAliases; i++) {
        if (strcmp(aliases[i].name, name) == 0) {
            return &aliases[i];
        }
    }
    return NULL;
}

void define_alias(const char* name, const char* value) {
    Alias* alias = find_alias(name);
    if (alias != NULL) {
        strcpy(alias->value, value);
    } else {
        if (numAliases == MAX_ALIASES) {
            printf("Maximum number of aliases reached.\n");
            return;
        }
        alias = &aliases[numAliases];
        strcpy(alias->name, name);
        strcpy(alias->value, value);
        numAliases++;
    }
}

void execute_cmd(char *av[], char *env[], char *cmd) {
    // Handle alias command
    if (strcmp(cmd, "alias") == 0) {
        char *token = strtok(NULL, " ");
        if (token == NULL) {
            print_all_aliases();
        } else if (strchr(token, '=') != NULL) {
            char *name = strtok(token, "=");
            char *value = strtok(NULL, "=");
            define_alias(name, value);
        } else {
            while (token != NULL) {
                Alias* alias = find_alias(token);
                if (alias != NULL) {
                    print_alias(alias);
                }
                token = strtok(NULL, " ");
            }
        }
    } else {
        // Handle other commands
        // ...
    }
}

int main(__attribute__((unused)) int ac, char *av[], char *env[]) {
    char *input = NULL;
    char *cmd = NULL;
    ssize_t rvalue = 0;
    size_t n = 0;

    while (1) {
        writes("simpleshell$ ", 1);

        rvalue = get_line(&input, &n, stdin);
        if (rvalue == -1)
            return -1;
        rmline(input);
        rmspace(input);
        rmit(input);
        cmd = strtok(input, ";");
        while (cmd != NULL) {
            rmspace(cmd);
            execute_cmd(av, env, cmd);
            cmd = strtok(NULL, ";");
        }
    }
    free(input);
    return 0;
}

